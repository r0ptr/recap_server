
// Include
#include "level.h"

#include "utils/functions.h"
#include "utils/log.h"

#include <filesystem>
// TODO: for all xml formats, use attributes aswell. (current data is autogenerated)

// Game
namespace Game {
	const std::string levelDataPath = "data/level/";

	const auto read_list = [](pugi::xml_node node, std::string_view nodeName, auto& list) {
		for (const auto& child : node.child(nodeName.data())) {
			if (!utils::string_iequals(child.name(), "entry")) {
				continue;
			}

			decltype(auto) data = list.emplace_back();
			data.Read(child);
		}
	};

	const auto read_vec3 = [](pugi::xml_node node) {
		glm::vec3 data;
		data.x = utils::xml_get_text_node<float>(node, "x");
		data.y = utils::xml_get_text_node<float>(node, "y");
		data.z = utils::xml_get_text_node<float>(node, "z");
		return data;
	};

	// TriggerVolumeEvents
	void TriggerVolumeEvents::Read(pugi::xml_node node) {
		mOnEnter = utils::xml_get_text_node(node, "onEnterEvent");
		mOnExit = utils::xml_get_text_node(node, "onExitEvent");
	}

	// TriggerVolumeData
	void TriggerVolumeData::Read(pugi::xml_node node) {
		mShape = utils::xml_get_text_node<TriggerVolumeShape>(node, "shape");
		mActivationType = utils::xml_get_text_node<TriggerVolumeActivationType>(node, "triggerActivationType");

		mOffset = read_vec3(node.child("offset"));

		mOnEnter = utils::xml_get_text_node(node, "onEnter");
		mOnExit = utils::xml_get_text_node(node, "onExit");
		mOnStay = utils::xml_get_text_node(node, "onStay");
		mLuaCallbackOnEnter = utils::xml_get_text_node(node, "luaCallbackOnEnter");
		mLuaCallbackOnExit = utils::xml_get_text_node(node, "luaCallbackOnExit");
		mLuaCallbackOnStay = utils::xml_get_text_node(node, "luaCallbackOnStay");

		mTimeToActivate = utils::xml_get_text_node<float>(node, "timeToActivate");

		mUseObjectDimensions = utils::xml_get_text_node<bool>(node, "useGameObjectDimensions");
		mIsKinematic = utils::xml_get_text_node<bool>(node, "isKinematic");
		mPersistentTimer = utils::xml_get_text_node<bool>(node, "persistentTimer");
		mTriggerOnceOnly = utils::xml_get_text_node<bool>(node, "triggerOnceOnly");
		mTriggerIfNotBeaten = utils::xml_get_text_node<bool>(node, "triggerIfNotBeaten");

		switch (mShape) {
			case TriggerVolumeShape::Sphere:
				mBoundingBox.extent = glm::vec3(utils::xml_get_text_node<float>(node, "sphereRadius"));
				break;

			case TriggerVolumeShape::Box:
				mBoundingBox.extent = glm::vec3(
					utils::xml_get_text_node<float>(node, "boxWidth"),
					utils::xml_get_text_node<float>(node, "boxHeight"),
					utils::xml_get_text_node<float>(node, "boxLength")
				);
				break;

			case TriggerVolumeShape::Capsule:
				auto radius = utils::xml_get_text_node<float>(node, "capsuleRadius");
				mBoundingBox.extent = glm::vec3(radius, utils::xml_get_text_node<float>(node, "capsuleHeight"), radius);
				break;
		}

		if (auto eventsNode = node.child("events")) {
			mEvents.Read(eventsNode);
		}
	}

	const BoundingBox& TriggerVolumeData::GetBoundingBox() const {
		return mBoundingBox;
	}

	const glm::vec3& TriggerVolumeData::GetOffset() const {
		return mOffset;
	}

	TriggerVolumeShape TriggerVolumeData::GetShape() const {
		return mShape;
	}

	TriggerVolumeActivationType TriggerVolumeData::GetActivationType() const {
		return mActivationType;
	}

	float TriggerVolumeData::GetTimeToActivate() const {
		return mTimeToActivate;
	}

	// TeleporterData
	void TeleporterData::Read(pugi::xml_node node) {
		mDestinationMarkerId = utils::xml_get_text_node<uint32_t>(node, "destinationMarkerId");
		mDeferTriggerCreation = utils::xml_get_text_node<bool>(node, "deferTriggerCreation");

		if (auto triggerVolumeNode = node.child("triggerVolume")) {
			mTriggerVolumeData = std::make_unique<TriggerVolumeData>();
			mTriggerVolumeData->Read(triggerVolumeNode);
		}
	}

	const std::unique_ptr<TriggerVolumeData>& TeleporterData::GetTriggerVolumeData() const {
		return mTriggerVolumeData;
	}

	uint32_t TeleporterData::GetDestinationId() const {
		return mDestinationMarkerId;
	}

	bool TeleporterData::DeferTriggerCreation() const {
		return mDeferTriggerCreation;
	}

	// MarkerInteractableData
	void MarkerInteractableData::Read(pugi::xml_node node) {
		mAbility = utils::xml_get_text_node(node, "interactableAbility");
		mStartInteractEvent = utils::xml_get_text_node(node, "startInteractEvent");
		mEndInteractEvent = utils::xml_get_text_node(node, "endInteractEvent");
		mOptionalInteractEvent = utils::xml_get_text_node(node, "optionalInteractEvent");

		mUsesAllowed = utils::xml_get_text_node<int32_t>(node, "numUsesAllowed");
		mChallengeValue = utils::xml_get_text_node<int32_t>(node, "challengeValue");
	}

	const std::string& MarkerInteractableData::GetAbility() const {
		return mAbility;
	}

	const std::string& MarkerInteractableData::GetStartInteractEvent() const {
		return mStartInteractEvent;
	}

	const std::string& MarkerInteractableData::GetEndInteractEvent() const {
		return mEndInteractEvent;
	}

	const std::string& MarkerInteractableData::GetOptionalInteractEvent() const {
		return mOptionalInteractEvent;
	}

	int32_t MarkerInteractableData::GetUsesAllowed() const {
		return mUsesAllowed;
	}

	int32_t MarkerInteractableData::GetChallengeValue() const {
		return mChallengeValue;
	}

	// Marker
	void Marker::Read(pugi::xml_node node) {
		mName = utils::xml_get_text_node(node, "markerName");
		mId = utils::xml_get_text_node<uint32_t>(node, "markerId");
		mNounName = utils::xml_get_text_node(node, "nounDef");
		mNoun = utils::hash_id(mNounName);

		mPosition = read_vec3(node.child("pos"));
		mRotation = read_vec3(node.child("rotDegrees"));
		mScale = utils::xml_get_text_node<float>(node, "scale");

		mVisible = utils::xml_get_text_node<bool>(node, "visible");
		mHasCollision = utils::xml_get_text_node<bool>(node, "createWithCollision");

		mOverrideAssetId = utils::xml_get_text_node<uint64_t>(node, "assetOverrideId");
		mTargetId = utils::xml_get_text_node<uint32_t>(node, "targetMarkerId");

		if (auto componentDataNode = node.child("componentData")) {
			if (auto teleporterNode = componentDataNode.child("teleporter")) {
				mTeleporterData = std::make_unique<TeleporterData>();
				mTeleporterData->Read(teleporterNode);
			}

			if (auto interactableNode = componentDataNode.child("interactable")) {
				mInteractableData = std::make_unique<MarkerInteractableData>();
				mInteractableData->Read(interactableNode);
			}
			/*
			SharedComponentData->add("eventListenerDef", nullable_type, std::tuple(0x08, EventListenerDef));
			SharedComponentData->add("spawnPointDef", nullable_type, std::tuple(0x10, SpawnPointDef));
			SharedComponentData->add("spawnTrigger", nullable_type, std::tuple(0x0C, SpawnTriggerDef));
			SharedComponentData->add("defaultGfxState", nullable_type, std::tuple(0x18, GameObjectGfxStateTuning));
			SharedComponentData->add("combatant", nullable_type, std::tuple(0x1C, CombatantDef));
			SharedComponentData->add("triggerComponent", nullable_type, std::tuple(0x20, TriggerVolumeComponentDef));
			SharedComponentData->add("spaceshipSpawnPoint", nullable_type, std::tuple(0x24, SpaceshipSpawnPointDef));
			*/
		}
	}

	const std::unique_ptr<TeleporterData>& Marker::GetTeleporterData() const {
		return mTeleporterData;
	}

	const std::unique_ptr<MarkerInteractableData>& Marker::GetInteractableData() const {
		return mInteractableData;
	}

	const glm::vec3& Marker::GetPosition() const {
		return mPosition;
	}

	const glm::vec3& Marker::GetRotation() const {
		return mRotation;
	}

	const std::string& Marker::GetNounName() const {
		return mNounName;
	}

	uint64_t Marker::GetOverrideAssetId() const {
		return mOverrideAssetId;
	}

	uint32_t Marker::GetId() const {
		return mId;
	}

	uint32_t Marker::GetNoun() const {
		return mNoun;
	}

	uint32_t Marker::GetTargetId() const {
		return mTargetId;
	}

	float Marker::GetScale() const {
		return mScale;
	}

	// Markerset
	bool Markerset::Load(const std::string& path) {
		const std::string fullPath = levelDataPath + path;
		if (!std::filesystem::exists(fullPath)) {
			std::cout << "Markerset: Could not find '" << fullPath << "'." << std::endl;
			return false;
		}

		pugi::xml_document document;
		if (auto parse_result = document.load_file(fullPath.c_str())) {
			auto node = document.child("markerset");
			if (node) {
				Read(node);
				return true;
			}
		} else {
			std::cout << "Markerset: Could not load '" << path << "'." << std::endl;
		}
		return false;
	}

	void Markerset::Read(pugi::xml_node node) {
		for (const auto& child : node.child("markers")) {
			if (!utils::string_iequals(child.name(), "entry")) {
				continue;
			}

			auto marker = std::make_shared<Marker>();
			marker->Read(child);

			mMarkersByNoun[marker->mNoun].push_back(marker);
			mMarkers.push_back(std::move(marker));
		}
	}

	const std::vector<MarkerPtr>& Markerset::GetMarkers() const {
		return mMarkers;
	}

	std::vector<MarkerPtr> Markerset::GetMarkersByType(uint32_t noun) const {
		if (auto it = mMarkersByNoun.find(noun); it != mMarkersByNoun.end()) {
			return it->second;
		}
		return {};
	}

	// DirectorClass
	void DirectorClass::Read(pugi::xml_node node) {
		mNounName = utils::xml_get_text_node(node, "mpNoun");

		mMinLevel = utils::xml_get_text_node<int32_t>(node, "minDifficulty");
		mMaxLevel = utils::xml_get_text_node<int32_t>(node, "maxDifficulty");

		mHordeLegal = utils::xml_get_text_node<bool>(node, "hordeLegal");
	}

	const std::string& DirectorClass::GetNounName() const {
		return mNounName;
	}

	int32_t DirectorClass::GetMinLevel() const {
		return mMinLevel;
	}

	int32_t DirectorClass::GetMaxLevel() const {
		return mMaxLevel;
	}

	bool DirectorClass::IsHordeLegal() const {
		return mHordeLegal;
	}

	// LevelConfig
	void LevelConfig::Read(pugi::xml_node node) {
		read_list(node, "minion", mMinions);
		read_list(node, "special", mSpecial);
		read_list(node, "boss", mBoss);
		read_list(node, "agent", mAgent);
		read_list(node, "captain", mCaptain);
	}

	DirectorClass LevelConfig::GetMinion(size_t idx) const {
		return mMinions.size() > idx ? mMinions[idx] : DirectorClass();
	}

	DirectorClass LevelConfig::GetSpecial(size_t idx) const {
		return mSpecial.size() > idx ? mSpecial[idx] : DirectorClass();
	}

	DirectorClass LevelConfig::GetBoss(size_t idx) const {
		return mBoss.size() > idx ? mBoss[idx] : DirectorClass();
	}

	DirectorClass LevelConfig::GetAgent(size_t idx) const {
		return mAgent.size() > idx ? mAgent[idx] : DirectorClass();
	}

	DirectorClass LevelConfig::GetCaptain(size_t idx) const {
		return mCaptain.size() > idx ? mCaptain[idx] : DirectorClass();
	}

	// Level
	Level::Level() {

	}

	Level::~Level() {

	}

	bool Level::Load(const std::string& difficultyName, const std::string& levelName) {
		const std::string fullPath = levelDataPath + difficultyName + "/" + levelName + ".level.xml";
		if (!std::filesystem::exists(fullPath)) {
			std::cout << "Level: Could not find '" << fullPath << "'." << std::endl;
			return false;
		}

		pugi::xml_document document;
		if (auto parse_result = document.load_file(fullPath.c_str())) {
			auto node = document.child("level");
			if (!node) {
				return false;
			}

			for (const auto& child : node.child("markersets")) {
				if (!utils::string_iequals(child.name(), "entry")) {
					continue;
				}

				const auto markersetAsset = utils::xml_get_text_node(child, "markersetAsset");
				if (markersetAsset.empty()) {
					continue;
				}

				const auto& [it, added] = mMarkersets.try_emplace(utils::hash_id(markersetAsset));
				if (added) {
					it->second.mName = markersetAsset;
					it->second.Load(difficultyName + "/" + markersetAsset + ".xml");
				}
			}

			mConfig.Read(node.child("levelConfig"));
			mFirstTimeConfig.Read(node.child("firstTimeConfig"));

			const auto planetConfigName = utils::xml_get_text_node(node, "planetConfig");
			if (!planetConfigName.empty()) {
				// mPlanetConfig.Read(open_the_file);
			}

			return true;
		} else {
			std::cout << "Level: Could not load '" << fullPath << "'." << std::endl;
		}
		return false;
	}

	bool Level::GetMarkerset(const std::string& name, Markerset& markerset) const {
		if (auto it = mMarkersets.find(utils::hash_id(name)); it != mMarkersets.end()) {
			markerset = it->second;
			return true;
		}
		return false;
	}

	const LevelConfig& Level::GetConfig() const {
		return mConfig;
	}

	const LevelConfig& Level::GetFirstTimeConfig() const {
		return mFirstTimeConfig;
	}

	const LevelConfig& Level::GetPlanetConfig() const {
		return mPlanetConfig;
	}
}
